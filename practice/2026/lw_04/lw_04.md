# Лабораторная работа №4.1. Создание и развертывание полнофункционального аналитического приложения


## Цель работы
Применить полученные знания по созданию и развертыванию трехзвенного приложения (Frontend + Backend + Database) в кластере Kubernetes. Научиться организовывать взаимодействие между микросервисами.

## Необходимые инструменты и технологии
Для выполнения работы потребуются:
*   **Платформа.** Виртуальная машина `dev_kub_student.ova` (Ubuntu + MicroK8s/Docker).  
    *   [Ссылка для скачивания образа](https://envlab.ru/mod/folder/view.php?id=1078)
*   **Язык программирования:** Python.
*   **Технологический стек (рекомендуемый):**
    *   **Backend:** FastAPI (современный, быстрый фреймворк для API).
    *   **Frontend:** Streamlit (библиотека для быстрого создания Data-интерфейсов) или HTML/JS (по желанию).
    *   **Database:** PostgreSQL (реляционная БД) или MongoDB (NoSQL).
*   **Инструменты:** Docker, Kubernetes (kubectl), Git.
*   **Репозиторий:** GitHub или GitVerse.

## Задачи
-  **Бэкенд.** Разработать API (FastAPI/Flask), которое выполняет CRUD-операции с базой данных.
-  **Фронтенд.** Разработать интерфейс (Streamlit), который обращается к API и отображает данные (таблицы/графики).
-  **Docker.** Написать Dockerfile для обоих сервисов, собрать образы и (опционально) загрузить их в Docker Hub или использовать локально.
-  **Kubernetes.** Написать манифесты (Deployment, Service) для БД, Бэкенда и Фронтенда.
-  **Развертывание.** Запустить приложение в кластере и проверить сквозную работу (БД <-> Бэк <-> Фронт).

## Критерии оценки (Всего 20 баллов)
| Критерий | Баллы | Описание |
| :--- | :---: | :--- |
| **Бэкенд (API)** | 4 | API запускается, соединяется с БД, корректно обрабатывает запросы (GET/POST). |
| **Фронтенд (UI)** | 4 | Интерфейс отображает данные, полученные от API. Формы отправки работают. |
| **Контейнеризация** | 4 | Dockerfile оптимальны, образы собираются без ошибок. |
| **K8s Манифесты** | 4 | Синтаксис YAML верен. Правильно настроены `env` переменные для связи сервисов. |
| **Итоговый деплой** | 4 | Все поды `Running`, приложение доступно из браузера хост-машины, данные сохраняются. |

---

## Ход работы (Пример. Аналитический портал продаж)

**Сценарий.** Приложение для ввода данных о продажах и их просмотра.
*   **DB:** PostgreSQL.
*   **Backend:** FastAPI.
*   **Frontend:** Streamlit.

### Шаг 1. Подготовка структуры
Создайте папки:
```bash
mkdir fullstack-app
cd fullstack-app
mkdir backend frontend k8s
```

### Шаг 2. Разработка Бэкенда (FastAPI)
Перейдите в папку `backend`.

1.  Создайте `requirements.txt`:
    ```text
    fastapi
    uvicorn
    psycopg2-binary
    sqlalchemy
    pydantic
    ```

2.  Создайте `main.py`:
    ```python
    from fastapi import FastAPI
    from pydantic import BaseModel
    from sqlalchemy import create_engine, Column, Integer, String, Float
    from sqlalchemy.ext.declarative import declarative_base
    from sqlalchemy.orm import sessionmaker
    import os
    import time

    # Ожидание БД (простая логика для примера)
    time.sleep(5)

    # Подключение к БД через переменные окружения
    DB_USER = os.getenv("DB_USER", "user")
    DB_PASSWORD = os.getenv("DB_PASSWORD", "password")
    DB_HOST = os.getenv("DB_HOST", "postgres-service")
    DB_NAME = os.getenv("DB_NAME", "sales_db")
    
    DATABASE_URL = f"postgresql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}/{DB_NAME}"
    
    engine = create_engine(DATABASE_URL)
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    Base = declarative_base()

    class Sale(Base):
        __tablename__ = "sales"
        id = Column(Integer, primary_key=True, index=True)
        item = Column(String, index=True)
        amount = Column(Float)

    Base.metadata.create_all(bind=engine)

    app = FastAPI()

    class SaleModel(BaseModel):
        item: str
        amount: float

    @app.get("/sales")
    def get_sales():
        db = SessionLocal()
        sales = db.query(Sale).all()
        db.close()
        return sales

    @app.post("/sales")
    def add_sale(sale: SaleModel):
        db = SessionLocal()
        new_sale = Sale(item=sale.item, amount=sale.amount)
        db.add(new_sale)
        db.commit()
        db.refresh(new_sale)
        db.close()
        return new_sale
    ```

3.  Создайте `Dockerfile`:
    ```dockerfile
    FROM python:3.9-slim
    WORKDIR /app
    COPY requirements.txt .
    RUN pip install --no-cache-dir -r requirements.txt
    COPY . .
    CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
    ```

### Шаг 3. Разработка Фронтенда (Streamlit)
Перейдите в папку `frontend`.

1.  Создайте `requirements.txt`:
    ```text
    streamlit
    requests
    pandas
    ```

2.  Создайте `app.py`:
    ```python
    import streamlit as st
    import requests
    import pandas as pd
    import os

    # Адрес бэкенда берем из ENV или дефолтный (важно для K8s)
    BACKEND_URL = os.getenv("BACKEND_URL", "http://backend-service:8000")

    st.title("Sales Analytics Dashboard")

    # Форма добавления
    st.header("Add New Sale")
    with st.form("sale_form"):
        item = st.text_input("Item Name")
        amount = st.number_input("Amount", min_value=0.0)
        submitted = st.form_submit_button("Add")
        
        if submitted:
            try:
                res = requests.post(f"{BACKEND_URL}/sales", json={"item": item, "amount": amount})
                if res.status_code == 200:
                    st.success("Added successfully!")
                else:
                    st.error("Error adding data")
            except Exception as e:
                st.error(f"Connection error: {e}")

    # Отображение данных
    st.header("Sales Data")
    if st.button("Refresh Data"):
        try:
            res = requests.get(f"{BACKEND_URL}/sales")
            if res.status_code == 200:
                data = res.json()
                if data:
                    df = pd.DataFrame(data)
                    st.dataframe(df)
                else:
                    st.info("No data available")
        except Exception as e:
            st.error(f"Cannot connect to Backend at {BACKEND_URL}: {e}")
    ```

3.  Создайте `Dockerfile`:
    ```dockerfile
    FROM python:3.9-slim
    WORKDIR /app
    COPY requirements.txt .
    RUN pip install --no-cache-dir -r requirements.txt
    COPY . .
    EXPOSE 8501
    CMD ["streamlit", "run", "app.py", "--server.port=8501", "--server.address=0.0.0.0"]
    ```

### Шаг 4. Сборка образов
В терминале соберите образы (находясь в папках backend и frontend соответственно):
```bash
# В папке backend
docker build -t my-backend:v1 .

# В папке frontend
docker build -t my-frontend:v1 .
```
*(Если используете MicroK8s, образы нужно импортировать в реестр MicroK8s или использовать `docker save/microk8s ctr image import`, либо использовать Docker Hub).*

### Шаг 5. Манифесты Kubernetes
Перейдите в папку `k8s` и создайте единый файл `fullstack.yaml` (или три отдельных).

**1. Database (Postgres):**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres-deploy
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:13
        env:
        - name: POSTGRES_USER
          value: "user"
        - name: POSTGRES_PASSWORD
          value: "password"
        - name: POSTGRES_DB
          value: "sales_db"
        ports:
        - containerPort: 5432
---
apiVersion: v1
kind: Service
metadata:
  name: postgres-service
spec:
  selector:
    app: postgres
  ports:
    - port: 5432
      targetPort: 5432
```

**2. Backend:**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend-deploy
spec:
  replicas: 1
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        # Укажите ваш образ. Если локально - imagePullPolicy: Never
        image: my-backend:v1 
        imagePullPolicy: IfNotPresent 
        env:
        - name: DB_HOST
          value: "postgres-service"
        ports:
        - containerPort: 8000
---
apiVersion: v1
kind: Service
metadata:
  name: backend-service
spec:
  selector:
    app: backend
  ports:
    - port: 8000
      targetPort: 8000
```

**3. Frontend:**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend-deploy
spec:
  replicas: 1
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: my-frontend:v1
        imagePullPolicy: IfNotPresent
        env:
        - name: BACKEND_URL
          value: "http://backend-service:8000"
        ports:
        - containerPort: 8501
---
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
spec:
  type: NodePort  # Чтобы открыть доступ снаружи
  selector:
    app: frontend
  ports:
    - port: 80
      targetPort: 8501
      nodePort: 30080
```

### Шаг 6. Развертывание и тест
1.  Примените конфигурацию:
    ```bash
    kubectl apply -f fullstack.yaml
    ```
2.  Проверьте поды:
    ```bash
    kubectl get pods
    ```
3.  Откройте приложение: `http://localhost:30080` (или IP вашей ВМ).

---

## Индивидуальные задания

Выберите вариант. 

Реализация. Бэкенд (Python/Node.js) + Фронтенд (Streamlit/React/HTML) + БД (Postgres/Mongo). 

**Рекомендуется стек Python (FastAPI + Streamlit + Postgres)** как наиболее актуальный для аналитики.

Задания на образовательном портале [IT-Adaptive](https://envlab.ru/mod/assign/view.php?id=259)

---

## Требования к отчетности

Все работы выгружаются в репозиторий на **GitHub** или **GitVerse**.

### Структура папки `lab_04.1`:
-  **src/**: Исходный код бэкенда и фронтенда.
-  **k8s/**: YAML-манифесты (deployment, service).
-  **REPORT.md**. Отчет.

### Содержание отчета (`REPORT.md`):
-  **Титульный лист**.
-  **Описание архитектуры**. Какие технологии выбраны, как сервисы общаются друг с другом.
-  **Листинги кода**. Основные файлы (main.py, app.py) и Dockerfile.
-  **Скриншоты**:
    *   Сборка образов.
    *   Статус подов (`kubectl get pods`).
    *   Работающее приложение в браузере (форма ввода и отображение таблицы).
-  **Ответы на контрольные вопросы**.

---

## Контрольные вопросы
1.  Что такое "трехзвенная архитектура" и какие компоненты в неё входят в рамках данной лабораторной?
2.  Как переменные окружения (`env` в Kubernetes) помогают связать Frontend, Backend и Database между собой?
3.  В чем разница между `ClusterIP` (используется по умолчанию) и `NodePort` при создании сервиса?
4.  Зачем разделять приложение на микросервисы (отдельно Front, Back, DB) вместо использования монолита?
5.  Если под с базой данных перезапустится, сохранятся ли данные в текущей конфигурации? (Подсказка: изучите понятие Persistent Volume, хотя в лабе мы использовали ephemeral storage).

```
